//! Wrapper for the Bad Words API from [apilayer](https://apilayer.com/)
//!
//! Provides a client for the Bad Words API, which can be used to check the profanity in the text and censor the text.

use reqwest_middleware::{ClientBuilder, ClientWithMiddleware};
use reqwest_retry::{policies::ExponentialBackoff, RetryTransientMiddleware};
use serde::{Deserialize, Serialize};
use tracing::{error, instrument, trace};

use crate::error::{APILayerError, ServiceError};

/// Bad Word object
///
/// Represents a single bad word in the text. Contains information about the original bad word,
/// the censored bad word, the number of deviations from the original word, the information about the bad word,
/// and the length of the replaced word.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BadWord {
    /// original bad word
    pub original: String,
    /// censored bad word
    pub word: String,
    /// number of deviations from the original word
    pub deviations: i64,
    /// information about the bad word, usually eqals 2
    pub info: i64,
    /// length of the replaced word
    #[serde(rename = "replacedLen")]
    pub replaced_len: i64,
}

/// Response from the Bad Words API
///
/// Contains the original content, the total number of bad words, the list of bad words, and the censored content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BadWordsResponse {
    /// original content
    pub content: String,
    /// censored content
    pub censored_content: String,
    /// total number of bad words
    pub bad_words_total: i64,
    /// list of bad words
    pub bad_words_list: Vec<BadWord>,
}

/// Bad Words API client
///
/// Client for the Bad Words API. Provides methods for checking the profanity in the text and censoring the text.
/// It uses the [reqwest] crate for making HTTP requests and the [reqwest_retry] crate for retrying the requests,
/// with the exponential backoff policy.
///
/// It sends the API key in the `apikey` header and uses the `censor_character` query parameter to replace the bad words in the text.
#[derive(Debug)]
pub struct BadWordsAPI {
    /// URL for the Bad Words API, generated by the [url](BadWordsAPI::url) method
    url: String,
    /// Client for the Bad Words API, with the retry policy and the API key header default values
    client: ClientWithMiddleware,
}

//noinspection DuplicatedCode
/// Error type for the Bad Words API client
///
/// Contains the possible errors that can occur when building the Bad Words API client
#[derive(thiserror::Error, Debug)]
pub enum BadWordsAPIBuildError {
    /// Invalid header value, usually occurs when the API key is not a valid string
    #[error("invalid header value: {0}")]
    BadAPIKeyValue(#[from] reqwest::header::InvalidHeaderValue),
    /// Failed to build the client object, usually occurs when the client cannot be built, because of the [reqwest] error
    #[error("failed to build client object: {0}")]
    ClientBuildError(#[from] reqwest::Error),
}

impl BadWordsAPI {
    /// API endpoint URL for the Bad Words API
    const API_ENDPOINT: &'static str = "https://api.apilayer.com/bad_words";
    /// Builds the URL for the Bad Words API
    ///
    /// Builds the URL for the Bad Words API using the provided censor character.
    /// Censor character is used to replace the bad words in the text
    ///
    /// # Parameters
    /// - `censor_char` - character to replace the bad words with
    ///
    /// # Returns
    /// - `String` containing the URL for the Bad Words API
    fn url(censor_char: char) -> String {
        format!("{}?censor_character={censor_char}", Self::API_ENDPOINT)
    }

    //noinspection DuplicatedCode
    /// Builds a new instance of the BadWordsAPI
    ///
    /// Builds a new instance of the BadWordsAPI using the provided API key and censor character.
    /// The API key is used to authenticate with the Bad Words API.
    /// The censor character is used to replace the bad words in the text.
    ///
    ///
    ///
    /// # Parameters
    /// - `api_key` - API key for the Bad Words API
    /// - `censor_char` - character to replace the bad words with
    ///
    /// # Returns
    /// - `Result` containing the new instance of the BadWordsAPI or an error
    pub fn build(api_key: &str, censor_char: char) -> Result<Self, BadWordsAPIBuildError> {
        let retry_policy = ExponentialBackoff::builder().build_with_max_retries(3);

        let mut headers = reqwest::header::HeaderMap::new();
        headers.insert("apikey", api_key.parse()?);

        let client = reqwest::Client::builder().default_headers(headers).build()?;

        let client = ClientBuilder::new(client)
            .with(RetryTransientMiddleware::new_with_policy(retry_policy))
            .build();

        Ok(BadWordsAPI {
            url: Self::url(censor_char),
            client,
        })
    }

    /// Checks the profanity in the text
    ///
    /// Sends the provided text to the Bad Words API and checks if it contains any bad words.
    /// If the text contains bad words, the response will contain the censored content.
    ///
    /// # Parameters
    /// - `text` - text to check for bad words
    #[instrument(level = "debug", skip(self))]
    pub async fn check_profanity(&self, text: String) -> Result<BadWordsResponse, ServiceError> {
        trace!("checking profanity in text: {}", text);
        let response = match self.client.post(&self.url).body(text).send().await {
            Ok(response) => response,
            Err(e) => {
                return Err(e.into());
            }
        };
        trace!(test_censored = response.status().is_success());

        if !response.status().is_success() {
            let client_error = response.status().is_client_error();
            let error = APILayerError::transform_error(response).await;
            return Err(if client_error {
                trace!("client_error: {}", error.message);
                ServiceError::ClientError(error)
            } else {
                trace!("server_error: {}", error.message);
                ServiceError::ServerError(error)
            });
        }

        response.json().await.map_err(|e| e.into())
    }

    /// Censors the text
    ///
    /// Shorthand method for checking the profanity in the text and returning the censored content.
    /// Directly returns the censored content from the response, returned by the [check_profanity](BadWordsAPI::check_profanity) method.
    #[instrument(level = "debug", skip(self))]
    pub async fn censor(&self, text: String) -> Result<String, ServiceError> {
        trace!("censoring text: {}", text);
        self.check_profanity(text).await.map(|res| res.censored_content)
    }
}
